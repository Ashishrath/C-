// In C++, you can create short functions that are not actually called; rather, their code
// is expanded in line at the point of each invocation. This process is similar to using a
// function-like macro. To cause a function to be expanded in line rather than called, 
// precede its definition with the inline keyword. For example, in this program, the
// function max() is expanded in line instead of called:

#include <iostream>
using namespace std;
inline int max(int a, int b)
{
    return a > b ? a : b;
}
int main()
{
    cout << max(10, 20);
    cout << " " << max(99, 88);
    return 0;
}

As far as the compiler is concerned, the preceding program is equivalent to this one:

#include <iostream>
using namespace std;
int main()
{
    cout << (10 > 20 ? 10 : 20);
    cout << " " << (99 > 88 ? 99 : 88);
    return 0;
}

// Each time a function is called, a significant amount of overhead is generated by the calling and return
// mechanism. Typically, arguments are pushed onto the stack and various registers are
// saved when a function is called, and then restored when the function returns. it can also result in larger code size because of duplicated
// code. For this reason, it is best to inline only very small functions. inline is actually just a request, not a command, to the
// compiler. The compiler can choose to ignore it.
// Inline functions may be class member functions. For example, this is a perfectly
// valid C++ program:

#include <iostream>
using namespace std;
class myclass
{
    int a, b;

public:
    void init(int i, int j);
    void show();
};
// Create an inline function.
inline void myclass::init(int i, int j)
{
    a = i;
    b = j;
}
// Create another inline function.
inline void myclass::show()
{
    cout << a << " " << b << "\n";
}
int main()
{
    myclass x;
    x.init(10, 20);
    x.show();
    return 0;
}
